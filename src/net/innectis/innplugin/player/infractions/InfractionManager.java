package net.innectis.innplugin.player.infractions;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import net.innectis.innplugin.Configuration;
import net.innectis.innplugin.handlers.datasource.DBManager;
import net.innectis.innplugin.InnPlugin;
import net.innectis.innplugin.player.PlayerCredentials;
import net.innectis.innplugin.player.PlayerCredentialsManager;
import net.innectis.innplugin.util.DateUtil;

/**
 *
 * @author Hret
 *
 * A manager that gets/adds all of the infractions for players.
 */
public class InfractionManager {

    /**
     * Amount of days before an infraction is no longer added to the infraction level.
     */
    private static final int INFRACTION_GRACE_DAYS = 14;
    private static final InfractionManager manager = new InfractionManager();
    private List<InfractionBan> infractionBans;

    private InfractionManager() {
        infractionBans = new ArrayList<InfractionBan>(6);

        // The different infraciton bans (intensitylevel, duration in seconds).
        // These need to be in order of infraction intensity!
        infractionBans.add(new InfractionBan(20, 6 * 3600)); // 6 hours
        infractionBans.add(new InfractionBan(24, 8 * 3600)); // 8 hours
        infractionBans.add(new InfractionBan(28, 24 * 3600)); // 1 days
        infractionBans.add(new InfractionBan(32, 3 * 24 * 3600)); // 3 days
        infractionBans.add(new InfractionBan(36, 7 * 24 * 3600)); // 1 week
        infractionBans.add(new InfractionBan(40, 30 * 24 * 3600)); // ~1 month
    }

    /**
     * Gets the default manager for infractions
     * @return
     */
    public static InfractionManager getManager() {
        return manager;
    }

    /**
     * This will store a new infraction into the database.
     * Existing infractions cannot be saved again, this behaviour will lead to an IllegalArgumentException.
     *
     * @param infraction The infraction to save into the database.
     * @return the infraction level of the player
     */
    public int saveInfraction(Infraction infraction) {

        // Check if its a new infraction
        if (infraction.getId() != Infraction.DEFAULT_ID) {
            throw new IllegalArgumentException("You cannot save an infraction that already exists!");
        }

        PreparedStatement statement = null;
        ResultSet set = null;

        // Save the infraction
        try {
            statement = DBManager.prepareStatementWithAutoGeneratedKeys(
                    "INSERT INTO player_infracts (player_id, intensity, dateGMT, summary, details, staff_id)"
                    + " VALUES (?,?,?,?,?,?); ");
            statement.setString(1, infraction.getPlayerCredentials().getUniqueId().toString());
            statement.setInt(2, infraction.getIntensity().getIntensityLevel());
            statement.setLong(3, infraction.getDateGMT().getTime());
            statement.setString(4, infraction.getSummary());
            statement.setString(5, infraction.getDetails());
            statement.setString(6, infraction.getCreatorCredentials().getUniqueId().toString());
            statement.execute();
            set = statement.getGeneratedKeys();

            if (set.next()) {
                infraction.setId(set.getInt(1));
            }

        } catch (SQLException ex) {
            InnPlugin.logError("Could not save infraction for '" + infraction.getPlayerCredentials().getName() + "'", ex);
        } finally {
            DBManager.closeResultSet(set);
            DBManager.closePreparedStatement(statement);
        }

        PlayerCredentials credentials = infraction.getPlayerCredentials();
        // Check if the player needs to be banned
        int infractionLevel = getInfractionLevel(credentials.getUniqueId(), credentials.getName());
        checkBans(infraction, infractionLevel);

        return infractionLevel;
    }

    /**
     * This will get the infraction level of the player.
     * The level is the sum of the intesity of all recent infractions.
     * @param playerId - The ID of the player to lookup.
     * @param playerName - The name of the player to lookup.
     * @return 0 or higher according to the infraction levle of the player. If an error occured -1
     * will be returend instead.
     */
    public int getInfractionLevel(UUID playerId, String playerName) {
        PreparedStatement statement = null;
        ResultSet set = null;

        try {
            Calendar cal = Calendar.getInstance(DateUtil.TIMEZONE_GMT);
            cal.add(Calendar.DAY_OF_WEEK, -INFRACTION_GRACE_DAYS);

            statement = DBManager.prepareStatement("SELECT sum(intensity) FROM player_infracts WHERE player_id = ? and dateGMT > ? AND revoker_id IS NULL");
            statement.setString(1, playerId.toString());
            statement.setLong(2, cal.getTimeInMillis());
            set = statement.executeQuery();

            if (set.next()) {
                return set.getInt(1);
            } else {
                return 0;
            }
        } catch (SQLException ex) {
            InnPlugin.logError("Could not get infractionlevel for '" + playerName + "'", ex);
        } finally {
            DBManager.closeResultSet(set);
            DBManager.closePreparedStatement(statement);
        }

        return -1;
    }

    /**
     * This will revoke the given infraction.
     * Revoking an infraction will cause the it to be updated with the given information.
     * @param infraction The infraction to revoke
     * @param revoker The name of the member that revoked the infraction
     * @param dateGMT The date that the infraction was revoked (GMT date).
     * @return the updated infraction if the update was succesfull, or NULL if it failed.
     */
    public Infraction revokeInfraction(Infraction infraction, String revoker, Date dateGMT) {
        // Check if its a new infraction
        if (infraction.getId() == Infraction.DEFAULT_ID) {
            throw new IllegalArgumentException("You cannot revoke a new infraction!");
        }

        PreparedStatement statement = null;

        // Update the infraction
        try {
            Calendar cal = Calendar.getInstance(DateUtil.TIMEZONE_GMT);
            cal.add(Calendar.DAY_OF_WEEK, -INFRACTION_GRACE_DAYS);

            statement = DBManager.prepareStatement(
                    "UPDATE player_infracts SET revoker = ?, revokeDateGMT = ? WHERE id = ? ");
            statement.setString(1, revoker);
            statement.setLong(2, dateGMT.getTime());
            statement.setInt(3, infraction.getId());

            statement.execute();

            // Return the updated infraction
            return getInfraction(infraction.getId());
        } catch (SQLException ex) {
            InnPlugin.logError("Could not save infraction for '" + infraction.getPlayerCredentials().getName() + "'", ex);
        } finally {
            DBManager.closePreparedStatement(statement);
        }

        return null;
    }

    /**
     * This will get a list with the infractions on the given player.
     * @param credentials - The credentials of the player to lookup.
     * @param all - When true all infractions will be returned instead of the infractions that comply
     * with the INFRACTION_GRACE_DAYS time setting.
     * @return A new list with the infracitons for the given player.
     * If an error occured Collections.EMPTY_LIST will be returned instead. The error itself will be
     * reported to the error logger.
     */
    public List<Infraction> getInfractions(PlayerCredentials credentials, boolean all) {
        PreparedStatement statement = null;
        ResultSet set = null;

        try {
            Calendar cal = Calendar.getInstance(DateUtil.TIMEZONE_GMT);
            cal.add(Calendar.DAY_OF_WEEK, -INFRACTION_GRACE_DAYS);

            // Construct the SQL
            String sql = "SELECT id, player_id, intensity, dateGMT, summary, details, staff_id, revoker_id, revokeDateGMT FROM player_infracts ";
            if (all) {
                sql += " WHERE player_id = ? ";
            } else {
                sql += " WHERE player_id = ? and dateGMT > ? AND revoker_id IS NULL ";
            }

            statement = DBManager.prepareStatement(sql);
            statement.setString(1, credentials.getUniqueId().toString());

            if (!all) {
                statement.setLong(2, cal.getTimeInMillis());
            }

            set = statement.executeQuery();

            // Build the infraction list
            List<Infraction> infractions = new ArrayList<Infraction>();

            while (set.next()) {
                infractions.add(infFromCurrentRow(set));
            }

            return infractions;
        } catch (SQLException ex) {
            InnPlugin.logError("Could not get infractions for '" + credentials.getName() + "'", ex);
        } finally {
            DBManager.closeResultSet(set);
            DBManager.closePreparedStatement(statement);
        }

        return Collections.EMPTY_LIST;
    }

    /**
     * This will return the infraction with the given ID.
     * If the ID does not exist, it will return NULL instead.
     * @param id
     * @return the infraction with the given ID or NULL.
     */
    public Infraction getInfraction(int id) {
        PreparedStatement statement = null;
        ResultSet set = null;

        try {
            statement = DBManager.prepareStatement("SELECT id, player_id, intensity, dateGMT, "
                    + " summary, details, staff_id, revoker_id, revokeDateGMT FROM player_infracts WHERE id = ?;");
            statement.setInt(1, id);
            set = statement.executeQuery();

            // Build the infraction list
            if (set.next()) {
                return infFromCurrentRow(set);
            }
        } catch (SQLException ex) {
            InnPlugin.logError("Could not get infraction '" + id + "'", ex);
        } finally {
            DBManager.closeResultSet(set);
            DBManager.closePreparedStatement(statement);
        }

        return null;
    }

    /**
     * This method will get the information that is on the current row of the resultset and convert
     * it into an Infraction object.
     * The method will not change any value of the resultset object itself.
     * @param set
     * @return Infraction object with information from the current row.
     * @throws SQLException
     */
    private static Infraction infFromCurrentRow(ResultSet set) throws SQLException {
        // Get normal information
        int id = set.getInt("id");

        String playerIdString = set.getString("player_id");
        UUID playerId = UUID.fromString(playerIdString);
        PlayerCredentials playerCredentials = PlayerCredentialsManager.getByUniqueId(playerId);

        int intensity = set.getInt("intensity");
        String summary = set.getString("summary");
        String details = set.getString("details");
        Date dateGMT = new Date(set.getLong("dateGMT"));

        String staffIdString = set.getString("staff_id");
        UUID staffId = UUID.fromString(staffIdString);
        PlayerCredentials staffCredentials = null;

        if (staffId.equals(Configuration.SERVER_GENERATED_IDENTIFIER)) {
            staffCredentials = Configuration.SERVER_GENERATED_CREDENTIALS;
        } else {
            staffCredentials = PlayerCredentialsManager.getByUniqueId(staffId);
        }

        // Get revoking details;
        String revokerIdString = set.getString("revoker_id");
        PlayerCredentials revokerCredentials = null;
        Date revokeDate = null;

        if (revokerIdString != null) {
            UUID revokerId = UUID.fromString(revokerIdString);
            revokerCredentials = PlayerCredentialsManager.getByUniqueId(revokerId);

            revokeDate = new Date(set.getLong("revokeDateGMT"));
        }

        // Get the infraction intensity
        InfractionIntensity infInt = InfractionIntensity.NOTICE;
        for (InfractionIntensity in : InfractionIntensity.values()) {
            if (in.getIntensityLevel() == intensity) {
                infInt = in;
            }
        }

        return new Infraction(id, playerCredentials, infInt, summary, details, dateGMT, staffCredentials, revokerCredentials != null, revokerCredentials, revokeDate);
    }

    /**
     * This method will check if any bans need to be added according to the infraction level.
     * @param infraction the infraction which caused the new infraction level
     * @param infractionLevel the new infractionlevel to check
     */
    private void checkBans(Infraction infraction, int infractionLevel) {
        // Only check when we have an infraction
        if (infraction != null) {
            InfractionBan ban = null;

            // Check if we triggered one of the bans.
            for (InfractionBan infBan : infractionBans) {
                if (infBan.getIntensityLevel() <= infractionLevel) {
                    ban = infBan;
                } else {
                    break;
                }
            }

            // We found a ban we must use
            if (ban != null) {
                ban.banPlayer(infraction);
            }
        }
    }
    
}
